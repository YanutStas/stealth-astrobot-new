const { Markup } = require("telegraf");
const axios = require("axios");
const { DateTime } = require("luxon");

const pending = require("../../pendingStore");
const logger = require("../../../logger");
const MODELS = require("../../../models");

/* ‚Äî‚Äî‚Äî –æ–±—â–µ–µ —Å–∏—Å—Ç–µ–º–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ ‚Äî‚Äî‚Äî */
const COMMON_SYS =
  "–¢—ã –¥—Ä—É–∂–µ–ª—é–±–Ω—ã–π –∞—Å—Ç—Ä–æ–ª–æ–≥-–ø—Ä–∞–∫—Ç–∏–∫. –ë–µ–∑ ¬´###¬ª, –ª–∏—à–Ω–∏—Ö –ø—É–Ω–∫—Ç–æ–≤, —Ä–µ–∫–ª–∞–º—ã. " +
  "–†—É—Å—Å–∫–∏–π —è–∑—ã–∫, –º–æ–∂–Ω–æ —ç–º–æ–¥–∑–∏. –°–µ–π—á–∞—Å 2025 –≥–æ–¥.";

const inProgress = new Map(); // uid ‚Üí true
const usage = new Map(); // uid ‚Üí { ts, count }
const DAILY_LIMIT = 30;

/* ‚Äî‚Äî‚Äî –∑–∞–ø—Ä–æ—Å –∫ LLM —Å –ø–æ–≤—Ç–æ—Ä–∞–º–∏ ‚Äî‚Äî‚Äî */
async function fetchLLM(model, messages, retries = 2) {
  for (let i = 0; i < retries; i++) {
    try {
      const { data } = await axios.post(
        "https://openrouter.ai/api/v1/chat/completions",
        { model, messages },
        {
          timeout: 20_000,
          headers: {
            Authorization: `Bearer ${process.env.OPENROUTER_API_KEY}`,
            "Content-Type": "application/json",
          },
        }
      );
      return (data.choices?.[0]?.message?.content || "").trim();
    } catch (e) {
      if (
        i < retries - 1 &&
        (e.code === "ECONNABORTED" || e.code === "ETIMEDOUT")
      )
        continue;
      throw e;
    }
  }
}

/* ‚Äî‚Äî‚Äî –æ—Å–Ω–æ–≤–Ω–æ–π —ç–∫—Å–ø–æ—Ä—Ç —Ñ–∞–±—Ä–∏–∫–∏ ‚Äî‚Äî‚Äî */
module.exports = function createPaidFeature(bot, flow, cfg) {
  const {
    key,
    buttonId,
    label,
    price,
    payUrl,
    payCard = "2200 2803 5427 7545", // –µ—Å–ª–∏ –Ω–µ—Ç payUrl ‚Äî –ø—Ä–µ–¥–ª–∞–≥–∞–µ–º –ø–µ—Ä–µ–≤–æ–¥ –Ω–∞ –∫–∞—Ä—Ç—É
    askText,
    waitText,
    hintText,
    regExp,
    sysMsg,
    buildPrompt,
    validate,
    maxDaily = DAILY_LIMIT,
    maxRetries = 2,
  } = cfg;

  const log = logger.child({ feat: key });

  /* ‚Äî –∫–Ω–æ–ø–∫–∞ –≤ –≥–ª–∞–≤–Ω–æ–º –º–µ–Ω—é ‚Äî */
  bot.action(buttonId, async (ctx) => {
    await ctx.answerCbQuery();
    flow.set(ctx.from.id, key);
    pending.set(ctx.from.id, { label, ask: askText });

    log.info({ uid: ctx.from.id }, "–ù–∞–∂–∞—Ç–∞ –∫–Ω–æ–ø–∫–∞");

    const paymentInstruction = payUrl
      ? `üí≥ –î–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è *${label}* —Å–¥–µ–ª–∞–π –¥–æ–Ω–∞—Ç *${price} ‚ÇΩ* –ø–æ —Å—Å—ã–ª–∫–µ:\n${payUrl}\n\n–ó–∞—Ç–µ–º –ø—Ä–∏—à–ª–∏ —Å–∫—Ä–∏–Ω—à–æ—Ç —á–µ–∫–∞ üëá`
      : `üí≥ –î–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è *${label}* –ø–µ—Ä–µ–≤–µ–¥–∏ *${price} ‚ÇΩ* –Ω–∞ –∫–∞—Ä—Ç—É:\n${payCard}\n\n–ó–∞—Ç–µ–º –ø—Ä–∏—à–ª–∏ —Å–∫—Ä–∏–Ω—à–æ—Ç —á–µ–∫–∞ üëá`;

    await ctx.reply(paymentInstruction, { parse_mode: "Markdown" });
  });

  /* ‚Äî –æ—Å–Ω–æ–≤–Ω–æ–π hears (–æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö –ø–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã) ‚Äî */
  bot.hears(
    (text, ctx) => flow.get(ctx.from.id) === key && regExp.test(text),
    async (ctx) => {
      const uid = ctx.from.id;

      if (inProgress.get(uid)) {
        await ctx.reply("‚è≥ –Ø –µ—â—ë –¥—É–º–∞—é –Ω–∞–¥ –ø—Ä–µ–¥—ã–¥—É—â–∏–º –æ—Ç–≤–µ—Ç–æ–º‚Ä¶");
        return;
      }

      /* —Å—É—Ç–æ—á–Ω—ã–π –ª–∏–º–∏—Ç */
      const dayStart = DateTime.local().startOf("day").toMillis();
      const stat = usage.get(uid) || { ts: dayStart, count: 0 };
      if (stat.ts !== dayStart) {
        stat.ts = dayStart;
        stat.count = 0;
      }
      if (stat.count >= maxDaily) {
        await ctx.reply(
          "üö¶ –õ–∏–º–∏—Ç –∑–∞–ø—Ä–æ—Å–æ–≤ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è –∏—Å—á–µ—Ä–ø–∞–Ω. –ü–æ–ø—Ä–æ–±—É–π –∑–∞–≤—Ç—Ä–∞!"
        );
        return;
      }

      const m = ctx.message.text.match(regExp);
      if (!m) {
        log.warn({ uid }, "–†–µ–≥—ç–∫—Å–ø –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª");
        return;
      }
      if (typeof validate === "function" && !validate(m)) {
        await ctx.reply(hintText, { parse_mode: "Markdown" });
        return;
      }

      inProgress.set(uid, true);
      stat.count += 1;
      usage.set(uid, stat);

      await ctx.reply(waitText);

      const userPrompt = buildPrompt(m);
      const systemMsg = `${COMMON_SYS}\n${sysMsg}`;
      const t0 = Date.now();

      try {
        for (const model of MODELS) {
          try {
            const answer = await fetchLLM(
              model,
              [
                { role: "system", content: systemMsg },
                { role: "user", content: userPrompt },
              ],
              maxRetries
            );

            log.info({ uid, model, t: Date.now() - t0 }, "–£—Å–ø–µ—à–Ω—ã–π –æ—Ç–≤–µ—Ç");
            await ctx.reply(
              answer || "üåå –ö–æ—Å–º–æ—Å –º–æ–ª—á–∏—Ç.",
              Markup.inlineKeyboard([
                [Markup.button.callback("–ù–∞–∑–∞–¥ ‚óÄÔ∏è", "back_to_menu")],
              ])
            );

            pending.delete(uid);
            flow.delete(uid);
            return;
          } catch (e) {
            log.warn(
              { uid, model, code: e.code || e.response?.status },
              "–û—à–∏–±–∫–∞ –º–æ–¥–µ–ª–∏"
            );
          }
        }

        await ctx.reply(
          "üõ†Ô∏è –ü–ª–∞–Ω–µ—Ç—ã –ø–µ—Ä–µ–≥—Ä—É–∂–µ–Ω—ã. –ü–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ.",
          Markup.inlineKeyboard([
            [Markup.button.callback("–ù–∞–∑–∞–¥ ‚óÄÔ∏è", "back_to_menu")],
          ])
        );
      } finally {
        inProgress.delete(uid);
      }
    }
  );

  /* ‚Äî –ø–æ–¥—Å–∫–∞–∑–∫–∞ –ø–æ —Ñ–æ—Ä–º–∞—Ç—É, –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤–≤—ë–ª —á—Ç–æ-—Ç–æ –ª–∏—à–Ω–µ–µ ‚Äî */
  bot.on("message", async (ctx, next) => {
    if (flow.get(ctx.from.id) === key) {
      await ctx.reply(hintText, { parse_mode: "Markdown" });
      return;
    }
    return next();
  });
};
